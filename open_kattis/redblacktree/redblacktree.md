# Red Black Tree

https://open.kattis.com/problems/redblacktree

Red black tree is a problem with a fairly simple solution but a difficult time complexity. You are given a tree of up to 2 \* 10^5 nodes, out of which 10^3 may be marked as red with the remainder left black. You are asked to select some set of nodes such that if node b is selected then no ancestor of b is selected and there are k red nodes selected total. For each k, calculate and print the total possible number of selections mod 10^9 + 7. 

We are going to approach this first by creating a recurrence relation and recursive solution and later transform it into an iterative solution so that we don't blow the stack. Lets consider a single node. In either case we could skip this node, giving one solution with 0 red nodes. If this node is red we can take it 1 extra possibility to select 1 red node. If this node is black we can select it for 1 extra possibility with 0 red nodes. Let's store these solution counts in an array. Now lets consider some node with some children. If we take this node we will get one solution, but we can't take any child nodes, so we can ignore them. On the other hand, if we don't choose this node we could choose any solution for each of our children nodes and know that it can safely combine with the other child solutions. If we want to find all of the solutions for this node including our children we would need to combine all of our child solutions by computing the convolution between them -> for each k in this nodes result, sum(sub1[i] * sub2[j] * .. subn) such that i+j+... == k. If we look at this carefully we can see that its possible to calculate pairwise and build our solution by successively adding children. Astute readers might notice that an FFT multiply would be applicable here, but this is best avoided as it causes issues with precision (10^21 doesn't nicely fit in any integer type). Instead we will use a naive multiplication and mod at each step which will just barely keep our bound under 2 \* 10^18. If we apply this relation to the whole tree we can calculate all the possibilities for each subtree and of course the possibilities at 0 are the possibilities for the whole tree which is exactly our solution.

Next lets consider some of the properties that computation might have. If we implement this recursively we could end up with a stack 2 \* 10^5 items deep, which would result in a segfault. Instead we need to calculate this iteratively with the order preserved. To iteratively calculate our DFS-order visits we can keep our own stack initialized with 0 and progressively pop the top item, insert it in our order, and push all the children. Once we have this order we'll need to reverse it so that we have every child calculated before its parent. Now we'll store each solution in a global solution vector, know that all of our children are precomputed by the time we reach any item, and use the same recurrence relation as before with no fear of a segfault.

This is all fine and dandy so far but there's something that we haven't yet addressed: Time Complexity! Naively this appears to be something like O(n \* m \* m) or worse because we could have m possibility levels at each node and need to do a recombine with some other subtrees also with up to m possibility levels. at 10^11, this would be far too slow if it was our time complexity. Lets consider the case of combining our possibilities for some subtree with a parent or other subtree made up of all black nodes. Since these black nodes cannot increase the number of red nodes chosen they also cannot change the length of our possibilities vector, and we can essentially remove them. The total time complexity that we might have for these recombines is O(n * m) because we might have m items on one side of each recombine but the other side with all blacks is restricted to a single item. With those removed we are left with a forest of red nodes to recombine. We'll use a similar idea to break this complexity down as we used in the problem Programming Team: consider a grid. To combine two trees we would take up ts1 by ts2 space, and have square subproblems of sizes ts1 and ts2 respectively. This all clearly fits onto the grid, so for these recombines we have O(m \* m) time, for a total of O((n+m) * m) time, which is doable at 10^8 in 7s.
