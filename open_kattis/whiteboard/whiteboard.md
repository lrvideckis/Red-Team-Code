# Whiteboard

https://open.kattis.com/problems/whiteboard

Whiteboard is an Ad hoc problem. You are given a grid of cells with two states: marked and unmarked. You are also given a list of moves that consist of a direction and a length. These represent the path that a marker has taken on the board. The marker may dry out at any integer time, and as soon as it does, it begins erasing cells instead of marking them. As cells may be visited multiple times, it is possible that there is a range of times that the marker could stop working. Our goal is to calculate this range.

To do so we first need to note that we only care about the last time we visit any cell. Regardless of whether the marker was writing or erasing in any of the passes before it, the last pass will determine what the cell value is. If we then consider all of last passes of the unmarked cells, we can take the minimum last pass and know that our marker must have been erasing there. Therefore the marker must have dried out sometime before then. We can do a similar consideration to prove a minimum time by looking at the maximum last pass of a marked cell. Any dry out between those two times must be valid because any mark or erase it might make must be overwritten by some later time; otherwise that time would have shown up as a last pass.

Next, we need to find a way to calculate our last passes efficiently. If we just naively follow the path, we might end up with 1m^2 cell visits, which is clearly out of time. Instead lets follow the path move by move doing length jumps and store each move at the position it starts at, along with its timestamp. Now if we do a walk downwards on a column, we will encounter each move at the place it starts. If we keep a set of open down moves, sorted by timestamp at this location, then at each spot we only need to consider the biggest move, and can use that to mark our cell. After each step we need to remove all the moves that ended at that spot, which we can easily do by also storing each move at the location it ends at. Once we do this for all four directons we do one final linear pass to get the min unmarked and the max marked, and print those as our ranges.

# Implementation details and time complexity

One implementation detail is how to handle a changing timestamp as we move cell to cell and preserve the ordering. Instead of just ordering on timestamp, we are going to order on timestamp - start index in direction with an implicit addition of our current index. This way when we move one cell we know that all of our calculated timestamps increase exactly by one, so our order doesn't change from that. Also when we step to a new spot we've already implicitly added in our spot to each location, so they still represent their true timestamps at this moment. This means that when we add in a new move at a given spot it has a true time of timestamp - start index + current location = timestamp, and it has an ordering value of timestamp - start index. Essentially this trick prevents us from needing to do any bookkeeping between steps to update our timestamps, instead we will recalculate the one we need from the best move at each spot.

Another detail and tip is to recognise that the logic is very similar between directions, with only a few loop indexes and signs needing to change. This means it's best to write and test one direction first and only copy the code once that is working and giving good results. This prevents you from needing to edit 4 parallel code chunks each time you make a small logic change.

Finally time complexity. For each direction we need to visit each cell once, add all the moves from it to our set, and remove all the moves that end there from our set. Since we only need to consider each move once, it will have one log(n) insertion and one log(n) removal. Calculating the greatest timestamp at each point is a log(n) lookup of the max element and then a constant time calculation. The last pass to calculate min unmarked and max marked values needs to visit each cell once, and has a constant time operation at each cell once. This is a total time complexity of n\*log(n), with a 4x constant factor. With bounds of 4s and n<=1m we are within time.
