# Compass Cards

https://open.kattis.com/problems/compasscard

Compass card is mostly a bookkeeping problem, with a few optimizations for speed. You are given a deck of cards each with an id and 3 color values in 0-360. The uniqueness of each card is calculated by finding the two cards remaining in the deck nearest it on each side of each color, and adding the angle differences. Our task is to successively remove the card with the lowest uniqueness, breaking ties by the highest id. Consider a deck with precalculated uniqueness values, and what we want to do to remove the smallest one and get updated uniqueness values. Each color value has at most two cards that will change their uniqueness if this card is removed. If we recalculate the uniquenesses for the six total items that may change we can build an updated list of uniquenesses. So that's the thrust of it, next question is how to make it fast enough. In order to quickly find the items to update we want to be able to find the angles on either side that are closest, so we need some way to get from each angle back to some item that has that angle. In addition, to repeatedly find the item with the min uniqueness we need to have all of the items in either a priority queue or tree/set. Finally, it's difficult to index into a tree/set and especially when the item may move so we want a statically located item to provide a step through. I solved this by creating a vector\<card\> to keep the canonical items, a map<id, loc> to return from an id to an item, a vector\<set\<id\>\> for each color wheel to get from angles to cards, and finally a set\<card\> sorted by uniqueness and -id to pull minimum elements out of. The bookkeeping is essentially all as described above: delete the minimum, update the six, and move on to the next. 

One extra note is that I used a linear search to find the neighbors in each direction. This works because each item that we remove is most likely not the last one in its color bucket, and as long as there is even 2 other items in the same color bucket we will break out of our linear search the first iteration. This leaves 3 * 2 * 360 possible linear searches with non-zero length. Even if we gretly overestimate an average length of 360 (total of 750,000 items) this will not push us over time.
