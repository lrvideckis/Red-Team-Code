# Alternative Bracket Notation

https://open.kattis.com/problems/bracketnotation

Alternative Bracket Notation is an ad hoc problem that doesn't really use any well known algorithm in it's solution. The problem essentially asks you to take a number of nested brackets and convert each bracket pair into a set of "x,y:" where x is the string index of the colon there, and represents the opening bracket of the pair, and y is the string index of the colon for the last closing bracket inside these two brackets. y may be the same as x if the brackets contain nothing, or it may be much later in the string. The hard part is calculating these xs and ys. Because both your xs and ys depend on the length of your xs and ys, numbers later in the sequence may change numbers earlier in the sequence. Instead of trying to manage updating each item that may have changed for each item that does change, we are going to create estimates that we can progressively make better until they are correct. The first task is to transform our brackets into a form so that we can easily calculate string positions based on an estimate. To do this we will assign an id to each bracket pair, walk through the string character by character, and store the indexes of the colons that each x and y will point to. Next we will make an array of colon locations, initialized to 4 (the smallest possible). Now, to calculate a new colon locations estimate we can step through the string and calculate a cumulative sum of the log10 of all the old colon locations pointed to so far, and store the values into our new colon locations. Since we are calculating colon locations as we go, we don't need to worry about doing back-updates for each number pointing to this colon; insted we only store the new estimated location, and use this estimate in our next loop. We will repeat this until our new estimate is the same as the old one, and finally print out the new notation.

## Time Complexity and Correctness
First question is correctness. Consider the loop invariant - each colon is less than or equal to its correct position. Taking a log10 of a number preserves order, so any underestimate of the colon locations will result in an underestimate of the log10s of the numbers, and our loop invariant is safe. Given that we only stop when the estimate is the same as the old estimate, we now know this algorithm is correct.
For time complexity, creating a new colon estimate will take linear time in the number of colons; The question is how many times might we have to re-estimate.
First consider the first re-estimate. Each colons x must be 4x its location in the string, and the ys must be at least as large as the xs. This means that we might have a few small digit numbers, but that most of our numbers must be 4 digits at least. This makes our string length after the first estimate around 4\*4000=16000 elements. Next lets consider how long our result string could be compared to our initial representation. Say every item was pointing to the last colon, so they were all equal to string length. There could be up to 2000 colons, so 4000 \* log10( endloc ). Starting at 4000, this gives estimates of 16000, and 20000, and then we are finished. Based on our earlier estimate we would need approximately (4000 \* (20000-16000)) = 16m operations which is doable in 2s.
If we take a closer look at how we calculate the complexity, we can prove it to be n^2. Let's consider the differences between our initial estimate and a maximal estimate. If we take all of the items and set them to the log10( endloc ) successively, we might move up one log10 after the first iteration, but after that we need to increase by a factor of 10 to go up again, which cannot be achieved by increasing our log10 factor by one. Next lets consider in the generalized case what our string length initial estimate might be. We might have any number of items in our largest log10 band, so let's add a possible step for each one. Next, for each of the bands below we will have approximately 1/10 of the last level, which leads to the geometric sum (1/10^n), which has a limit at 1/9. This means that we have a total linear error in our first estimate due to different string lengths, an additional linear distance on top of that to the maximal estimate, and finally a linear recomputation for each of those steps, meaning that we have overall O(n^2) time.
