# Alternative Bracket Notation

https://open.kattis.com/problems/bracketnotation

Alternative Bracket Notation is an ad hoc problem that doesn't really use any well known algorithm in it's solution. The problem essentially asks you to take a number of nested brackets and convert each bracket pair into a set of "x,y:" where x is the string index of the colon there, and represents the opening bracket of the pair, and y is the string index of the colon for the last closing bracket inside these two brackets. y may be the same as x if the brackets contain nothing, or it may be much later in the string. The hard part is calculating these x's and y's. Because both your x's and y's depend on the length of your x's and y's, numbers later in the sequence may change numbers earlier in the sequence. Instead of trying to manage updating each item that may have changed for each item that does change, we are going to create estimates that we can progressively make better until they are correct. The first task is to transform our brackets into a form so that we can easily calculate string positions based on an estimate. To do this we will assign an id to each bracket pair, walk through the string character by character, and store the indexes of the colons that each x and y will point to. Next we will make an array of colon locations, initialized to 4 (the smallest possible). Now, to calculate a new colon location estimate, we can step through the string and keep a cumulative sum of the log10 of all the colon locations pointed to so far. We will repeat this until our new estimate is the same as the old one, and finally print out the new notation.

## Time Complexity and Correctness
First question is correctness. Consider the loop invariant - each colon is either in its correct position or before its correct position. Taking a log10 of a number preserves order, so any underestimate of the colon locations will result in an underestimate of the log10s of the numbers, and our loop invariant is safe. Given that we only stop when the estimate is the same as the old estimate, we now know this algorithm is correct.
For time complexity, creating a new colon estimate will take linear time in the number of colons; The question is how many times might we have to re-estimate. Consider how long our result string could be compared to our initial representation. Say every item was pointing to the last colon, so they were all equal to string length. There could be up to 2000 colons, so 4000 \* log10( endloc ). Starting at 4000, this gives estimates of 16000, and 20000, and done. If we say that our new string must be within a factor of log10(n) of our original string distance, and know that at least every other estimate must increase our string length, we have a time complexity of O(n items \* (n \* log10(n)) re-estimates). For 4000, this is plenty doable.