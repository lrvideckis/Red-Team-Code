# Tour de France

I had the correct assumption on this problem. Given that there are <= 2 incoming and outgoing edges per node, a brute force DFS approach is fast enough to work, although for an unintuitive reason. The mistake I initially made was to memoize it, which added just enough overhead to put us over the time limit during the contest.

The correct solution was a plain DFS, with a non-obvious answer as to why that works. Each edge has <= 2 outgoing edges, <= 2 incoming edges, and must be visited exactly once. This means that whenever we choose an edge to be part of our path, we know two things: The other outgoing edge of the from node is not in our path, and the other incoming edge of the to node is not in our path. We can throw those two out. Next, we know that the to node of the outgoing edge that we threw out must be reached by its other incoming edge, so we know that is a part of our path. This chain may stop there (if that edge comes from the same node our other option went to), or it may continue. Either way each choice we make decides at least 4 edges in our path: 2 that we cannot take, and 2 that we must take. This make the total number of paths that we might have to consider < 2^(36 / 2) = 2^18 ~= 250000. At 5 test cases per run my implementation comes in just fast enough at 1.85 seconds out of 2.

A few optimizations may/may not be important to getting this fast enough. The first, most obvious one is that I used a greph representation that allows easy access to all outgoing edges of a node, which makes DFS fast and easy to write. Another optimization was to use a single long long to hold the visited nodes, as we were guaranteed <=36 of them. 
