# Tour de France

I had the correct assumption on this problem. Given that there are <= 2 incoming and outgoing edges per node, a brute force approach is fast enough to work. The mistake I initially made was to memoize it, which added just enough overhead to put us over the time limit.

The correct solution was a plain DFS, with a non-obvious answer as to why that works. Each edge has <= two outgoing edges, <= 2 incoming edges, and must be visited exactly once. This means that whenever we choose an edge to be in our search, we know two things: The other outgoing edge of the from node is not in our path, and the other incoming edge of the to node is not in our path. We can throw those two out. Next, we know that the to node of the outgoing edge that we threw out must be reached by its other incoming edge, so we know that is a part of our path. This chain may stop there, or it may continue, but each choice we make decides at least 4 edges in our path: 2 that we cannot take, and 2 that we must take. This make the total number of paths that we might have to consider << 2^(36 / 2) = 2^18 = 250000. At 5 test cases per run my implementation comes in just fast enough at 1.85 seconds out of 2.
