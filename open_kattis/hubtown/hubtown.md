# Hubtown

https://open.kattis.com/problems/hubtown

Hubtown is a max flow/bipartite matching problem with a specific structure that allows for a few optimizations to be made. Essentially you have a number of citizens that are living near different train rays, and can choose between the closest trains to them as long as those trains do not exceed their carry capacity. Some citizens may only have a single train nearest to them, whereas others may have the same angular distance to two different trains and be allowed to choose between them. We can simply allocate all of the people with singular trains to their train first, as there's no way that moving them off that train would allow more than one other extra person to ride any train, and after that we have to start making choices. For all of the people that can choose trains we want to find the maximum people that can ride total. Imagine this as a graph with a node for each set of people with identical choices, an edge to each of their train choices of capacity according to their size, and an edge from each train to the sink with the trains remaining carry capacity. This is clearly a max flow graph with a max node count equal to the number of distinct angles. Since we have to only consider things that have equivalent angular distances on each side, this severely restricts our node count (people must split the angles, so any train pair x/y and x2/y2 must have some (x/y+x2/y2)=(x\*y2+y\*x2)/y\*y2, with both top and bottom under 1000. Those numbers approximately double each split, but have twice as many locations each split, meaning the total possible angles is proportional to our size, 1000) Ford Fulkerson then can solve our problem in Edges * flow ~= 1000^2 time. 

That done, lets consider what will happen as we run our max flow. While there is capacity left, items will be assigned to trains immediately next to them, but once trains are full, people will be forced to begin taking backedges around the hub. This is similar to bumping one person coming to the train from the other direction off and attempting to place them on the next train, repeating as necessary. If we are clever with our allocations, we can make all of these bumps happen in a deterministic way, optimize for that, and come to the same result. Lets first consider walking around our hub clockwise and allocating as many people as we can first to their left train, and then to their right train. So far, this is identical to max flow. Next, lets take whatever people remain in between trains after our last step and try to insert them, specifically bumping to the right. Since we've always allocated everything we could to the left trains first, we know that there are no bumps in that direction that can find extra space. If there ever is space left on a left train, there will be no people on the right train to bump over to it. Now, as we bump people to the right we don't need to look ahead to see if our bumps are successful, because even if they fail we keep the same total number of people. This means that we can take the maximum of possible and needed bumps at each step on our loop around the second time. This is fairly similar to how max flow might take backedges. For each bump that we start here there are three ends: 1 is we find some train with space left and settle there; 2 is we come to some train with no bumps possible, and die there; 3 is we come all the way around the hub and return to the start, meaning that there is no extra capacity left anywhere in the cycle, and we can safely die. In all three cases either we gained flow or proved that there was none to be gained. We have to allocate and bump each person at most once, so this comes out to total linear time.