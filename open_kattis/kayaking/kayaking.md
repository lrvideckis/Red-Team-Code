# Kayaking

https://open.kattis.com/problems/kayaking

Kayaking involves allocating people to boats such that the we have the fastest possible slowest boat. We are given counts and strengths of three different types of people (b < m < e in strength), as well as a list of boat base speeds, with the resulting speed being (p1 + p2) * boat. Our first instinct was dynamic programming, but with 100,000 possible people in three directions, it was clear that would be far too large. Our next instinct was to look at some sort of greedy solution, or to prove some invariant of any solution that would allow us to restrict our search space. The trouble was that we have the relations bb < bm < mm < me < ee and bm < be < me, but not any way to relate be to mm (with < meaning it's strictly better to take the left pair over the right at a given boat if possible). If we allocate too many be's or mm's, it may mean that later in our solution we do not have enough of the other pairs to finish this solution where a better allocation would have succeeded. The solution to this was to restrict our test to seeing if a given score can be achieved. With this restriction, we can begin allocating bb, bm, me, and ee's as needed from the two ends, and finally allow whatever pairs may fit best in the middle section. This only works because when we know what our goal is at the outset we can see which boats can allow a bb/bm or need a ee/em. With this greedy test in hand, binary searching over the answer space (k <= 10^9) gives us a tidy N \* log(k) solution.