# Programming Team

https://open.kattis.com/problems/programmingteam

This unfortunately named problem is a binary search and dynamic programming problem. The solution is very specific and easy to miss. You are given a tree of people each with a salary cost and a productivity. You are asked to hire people such that for everyone hired their parent person is hired and the total ratio of salary to productivity is maximized. Approaching this from the idea of maximising our ratio is incredibly difficult, as each employee adds to both the bottom and top of the fraction and can completely change its value. Instead let's approach it from the standpoint of trying to test if a given ratio is possible. Since we are given the ratio, we can now rewrite our equation to look something like sum(productivities) = ratio * sum(salaries). This allows us to transform our fraction into a simple sum, which is easy to recombine. We will now do some dynamic programming, storing the best possible sum for each subtree and ct of nodes used. If we are careful with our indexing we can combine each item with its subtrees in O(n^2) time total. We will do this by taking the possible solutions from each subtree in order and for each possible supertree count add the different solutions to it and maximize them into the supertree array. In total for each subtree recombine we will have O((n - i) * i) operations in the recombine and T(n-i) + T(i) subproblem complexity. It's a bit difficult to see how this results in O(n^2) time complexity, so let's approach it from a different angle using geometry. Imagine that we have a n by n grid, When we split this into subproblems there are 3 parts: the (n - i) by i rectangle that represents the recombine, The (n - i) by (n - i) square above that that represents the T(n-i) subproblem, and a similar i by i square that represents the T(i) subproblem. This all fits into our n by n grid easily.
