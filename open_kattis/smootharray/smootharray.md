# smootharray

https://open.kattis.com/problems/smootharray

Smooth Array is a problem from our last regional. It involves an array of numbers and counting how many we might need to change to make it ks-smooth, meaning that every subarray of k numbers sums to exactly s. The first approach I considered was a memoized search, running through each number at each spot and failing out early when our s went negative. This immediately runs into the issue of needing to know what number was chosen K numbers ago, so that we can remove that from our sum when we step past the k-th item. This difficulty is solved by noticing that every k-distant pairs must be the same number, because they can be summed with the same k-1 size subarray. We can then remove the problem by making our array into an array of lists, with the list representing the numbers in this k-bucket. Now when doing recursive calls, we count the number of items of a given size in a bucket and use that to find how many we might need to change for this bucket. This still leaves us with 5k locs \* 5k remaining sums \* 5k choices at each spot - Far too large. We can reduce this by noticing that if we make an arbritrary choice for items ai and aj, it's the same as choosing 0 and ai + aj. Let's keep a boolean to tell if we have made such a choice, and instead of running through all 5k choices we'll try the few choices that exist in our k-bucket (5k total) and 0 at each spot, setting the any flag if we do. When coming to the end, instead of just checking for a sum of s, if we fall short we can use the any flag to bump us up for free, having already counted those changes. This reduces our time complexity to 5k locs \* 5k remaining sums \* 2 any states, with choices per stage being negligible. This comes to ~= 10m, which is fast enough using a table (but not unordered maps) to do in 3s.