# Key to Knowledge

https://open.kattis.com/problems/keytoknowledge

Key to Knowledge is a very obfuscated subset sums problem. We are given a number of student's T/F quiz answers and scores and are asked to construct the correct test or tell how many possible correct tests exist. We solve this problem in several phases. The first phase is encoding each possible answer of each test question into a score. Consider each score as an array with a cell for each student. This array will count up the number of questions each student has got right. With this in mind, we will create two scores per question; one for the students that answered 0 and one for the students that answered 1. Now, if we take a test and add up all the scores based on the correct answers, cell by cell, we can know the answer is valid if the numbers in the array correspond to the counts of questions each student got correct. This algorithm is too slow so far- we have 30 questions to consider and the dynamic subset sum counting algorithm is still exponential time. However, we can make this fast enough by splitting this down the middle. If we do the subset sum counting for the first 15 questions and another subset sum counting for the next 15 questions, we will have two lists of manageable size. Sort both of those, and we can walk through them in linear time to search for correct test answers. Wherever we find correct test answers we will multiply the two counts together and add it to our total sum of possible tests. This leaves as an afterthought the case of a single test. To solve this last bit we will store with each item in our subset sum algorithm the score that was most recently added when this item was first created. Because there was only one correct test, it must have been the first path through each of the items that it touched (otherwise it would have a count > 1) Therefore we can use those counts to walk backwards though the path that our singular test took in order to recreate that test.

## Time Complexity and Optimizations
We used a variant of the dynamic subset sum algorithm that uses a map instead of an array. This allows us to calculate all of the possible sums at the cost of some extra complexity over the typical algorithm. We will insert 2^15 ~= 33000 items in each sum, and each insert will take log(2^15) time, for about 500,000 operations per subset sum. We need to do two of those, and then the linear walk to find correct tests by combining them, for a total order of ~= 1m operations per test case. The overall time complexity ends up being O(n \* mlog(m) \* 2^(m/2)) because the log for the map becomes m, and although we can pack all of the test scores into a single long long with this test case, as the number of students or questions grows, so must the space and time taken on our sums, adding in a factor of n \* log(m).

For some optimizations, we subtracted the smaller score of each of the questions answers from both question scores and the final score. This way we preserve our results, but reduce the number of spots that are introduced to our map, as a score of 0 will simply double each locations count rather than introducing a new node. We were also fairly lucky to be able to pack each score into a long long, thus allowing us to use builtin math for our score calculations. 
