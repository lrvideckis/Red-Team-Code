# Factor Free

https://open.kattis.com/problems/factorfree

Factor Free has a devilishly simple trick to getting it into time complexity, and then a painful coding process. The goal is to reconstruct a tree such that each item is coprime with each of its ancestors. This means that the root must be coprime to everything, the left child must be coprime to its entire subtree, and so on. You can shortcut the coprime testing by using a sieve of erasthones to factor each number, grouping the factor locations, and marking the nearest non-coprime numbers for each item in the array, but you are then left with the problem of how to find whatever 1 item might cover the whole subtree. A linear search seems too slow, but there doesn't appear to be a way to structure the numbers so we can find a cover quickly. The trick is to do a linear search, but from both ends. This way we get the recurrence relation of T(n) = 2x + T(x) + T(n - x), with 0 <= x <= n/2. This almost looks like we can plug it into masters theorem, and with a little tweaking we can; say x is close to 0, constant, Then T(x) and 2x are going to be small and constant, and it becomes total linear. Say instead that x is some fraction 1/h of n. then we have T(1/h) + T(1 - 1/h). That second term may contain up to h-1 T(1/h), so we could rewrite as h/(h-1) \* T((h-1)/h). That then gives us linearithmic time under masters theorem. 

All that done, there are several difficulties with coding it up. First off, you need to know how to write a modified sieve of erasthones to allow factoring in log(k) time. Next you need to use those factors to create your previous and next arrays in a total of n * log(k) time. Lastly, you need to realize that the problem may generate a rope instead of a tree, and use your own manual stack to imitate a call stack and prevent overflow that you might otherwise get if you tried to solve this problem in a recursive way. 