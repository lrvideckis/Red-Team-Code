# Galactic Programming Competition

https://open.kattis.com/problems/gcpc

GCPC is a simple problem that has several possible solutions. We went for one that requires some more knowledge of c++, but gives us a very simple solution. Essentially you are required to keep a scoreboard of different programming teams and are given a number of updates which each indicate that a team has solved a new problem. After each update, you are asked to recompute the position of a favorite team while allowing for ties. One solution would be to keep a balanced binary tree of teams, and for each event do a removal and an insertion to move the team to its new position. In order to find each item by its team index in the tree efficiently, you would need to keep an array of pointers into the tree, as well as parent pointers. Finally, to get the count at each event, you would store the subtree size at each node and walk upwards from the favorite team, counting appropriate subtrees as you went. Being that C++ has no tree structure, this becomes a massive amount of code to write and get correct. A better solution is to keep two sets: one for the items above the favorite team, and another for ones below, as well as an array storing each team. Then for each move that isn't the favorite team, you can compare with the favorite to see which set the changing team is in, and do appropriate deletes/creates to simulate the move. Then when moving the favorite team, you do a binary search on the greater set to find the elements that now need to be pushed down to the below set. This comes to a total N \* log(N) time because each item must do at most two set inserts/deletes except for the favorite team which will do at most N inserts/deletes over all the queries because each item in the greater set had to have at least one event to move it into the greater set, and can only be moved down once each time it is moved up. Finally, with some esoteric C++ knowledge, we were able to use indexed_set to eliminate the need to keep seperate sets, instead using a log(n) query to find the index of our favorite key at each query, preserving the N \* log(N) complexity but making the code much more consise.