# Antiarithmetic

https://open.kattis.com/problems/antiarithmetic

Antiarithmetic is a problem where you need to consider all subsequences of a permutation and check if they are an arithmetic progression, meaning that no three elements have ai + s = aj = ak - s, for i < j < k. One way to solve it that I assume is too slow is to keep a set of the items seen so far, walk through the permutation and for each item in the set, check if the item that would create an arithmetic progression already exists in the set. If it does we are safe, otherwise it must appear later in the sequence and we can safely fail out. This could work but it is fairly slow, requiring n\*n\*log(n)/2 time with a normal set, or n\*n/2 if you use a seen vector. With 10,000 elements this may seem too slow at first glance, but with a few clever optimizations we can make it significantly faster. Let's keep the same idea (brute force test of each 2 items), but reorder it a bit. Instead of checking in the order that the numbers appear in the permutation let's check each progression in order by difference and then in order from 0 upwards and answer our questions by comparing their indexes. This has several nice properies: we can now avoid needing to check any two items that could never create an arithmetic progression, and we can make our inner for loop consist of only three integer comparisons: comparing the first and second and second and third indexes in our sequence and checking if they are the same direction. This has a significantly smaller constant factor than before and is fast enough to pass. 
