# Atlantis

https://open.kattis.com/problems/atlantis

Atlantis is a problem from our last regional. It involves a list of places with a travel time and an expiry time. To score a place you need to visit it before its expiry time. You are asked to maximize the number of places visited. First thought, as always, is dynamic programming. We would need the current item we're on and the current time we've used up to now. Times are large (10^9), so this is clearly not it. What if we reverse it? We know that for the last element if we take it is best placed at the very end, to maximize the amount of time left for other elements. That said, we still have the time problem - items can be shifted an arbrirary amount backwards. Let's take another tack; It's definitely better to insert a smaller element, all else being equal. What about if we have some partial solution, and want to add one of a number of other elements to it? It's definitely good to insert smaller elements, but does timing affect our choices? Let's consider if we add some small element how many other elements could possibly be inserted instead of that smallest element. If there is some large item ahead of us that only peeks into the space we took up we could block him but that would require that whatever space is left be less than us, which means that any other element that we block would need to be smaller than us to fit there. If there is some element past both of us that could possibly be large also and peek into our space, but since the nearer element is larger than us there's no way that the far one would be able to fit with that one and not us. The other case is that we are peeking into some space and blocking a larger element there, but this hits the same problem: whatever space is left after replacing us with that larger element and some other could be taken by us instead. So, those invariants proved means that we can construct a solution iteratively by keeping track of the free space left before each location and repeatedly adding the next smallest element that fits. We'll need a data structure that can do both range sets and prefix sums, which is definitely a segment tree. We'll take the elements in order from smallest to largest, check the prefix sum to see if they are addable, if addable we'll increment our count and "insert" them by reducing the capacity before them by their size, and finally print our count. So how do "inserts" work? We need to reduce the capacities starting from the insertion point and working left until we've drained our element's size capacity. With some custom segment tree code you could just write this operation and be careful to remove those nodes that have zero capcity, or with a lazy segment tree you can write this as a binary search to find the largest range from i to height with capacity less than needed, do the range set to 0, and then finally remove whatever remainder from the next item to the left. For the custom segment tree code we have complexity n\*log(n); for the lazy w/ binary search it is n\*log(n)^2. Both are fast enough to pass. 